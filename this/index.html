<script>
  function test01() {
    var x = 1; //window全局变量
    function foo() {
      //this是全局对象
      console.log(this.x);
    }
    foo(); // 1
  }

  function test02() {
    var x = 10;
    var obj = {
      x: 20,
      f: function () {
        console.log(this.x);
        var that = this;
        //使用that保留当前函数执行上下文的this
        var foo = function () {
          console.log(that.x);
        };
        //此时foo函数中的this仍然指向window，但我们使用that取得obj
        foo(); // foo.call(window)
      }
    };
    obj.f();// obj.f.call(obj);
  }

  var x = 10;
  function test03() {
    var obj = {
      x: 20,
      f: function () {
        console.log(this.x);
      }
    };
    obj.f();// obj.f.call(obj) // 20 
    var fOut = obj.f;
    // this在执行时才会被确认
    fOut();// fOut.call(window) // 10 
    var obj2 = { x: 30, f: obj.f };
    obj2.f(); // obj2.f.call(obj2) // 30
  }

  function test04() {
    var name = "windowsName";
    var a = {
      name: "Cherry",
      func1: function () {
        console.log(this.name)
      },
      func2: function () {
        setTimeout(function () {
          this.func1();
        }, 100);
      }
    };
    // 在不使用箭头函数的情况下，最后调用 setTimeout 的对象是 window
    a.func2();// this.func1 is not a function
  }

  function test05() {
    var name = "windowsName";
    var a = {
      name: "Cherry",
      func1: function () {
        console.log(this.name)
      },
      func2: function () {
        setTimeout(() => {
          this.func1()
        }, 100);
      }
    };
    a.func2();// Cherry
  }

  function test06() {
    var name = "windowsName";
    var a = {
      name: "Cherry",
      func1: function () {
        console.log(this.name)
      },
      func2: function () {
        // 防止在 func2 中的 setTimeout 被 window 调用而导致 this 指向 window
        var _this = this;
        setTimeout(() => {
          _this.func1()
        }, 100);
      }
    };
    a.func2();// Cherry
  }

  test06();
</script>